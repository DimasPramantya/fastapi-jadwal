# -*- coding: utf-8 -*-
"""cara2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1njBZOBTz0GLYSpENCZHuIO1tW05AAFuo
"""

import random
import math
import matplotlib.pyplot as plt

class Kelas:
    def __init__(self, nama, kapasitas, shift):
        self.nama = nama
        self.kapasitas = kapasitas
        self.shift = shift

class Dosen:
    def __init__(self, nama, preferred_time_slots, mengajar):
        self.nama = nama
        self.preferred_time_slots = preferred_time_slots
        self.mengajar = mengajar

class Schedule:
    def __init__(self, start_time, end_time, day):
        self.start_time = start_time
        self.end_time = end_time
        self.day = day

class CourseClass:
    def __init__(self, nama, is_lab=False):
        self.nama = nama
        self.is_lab = is_lab

class Room:
    def __init__(self, nama, kapasitas, is_lab=False):
        self.nama = nama
        self.kapasitas = kapasitas
        self.is_lab = is_lab

# Example Data
classes = [
    Kelas("TI-20-PA", 20, shift="pagi"), Kelas("TI-21-PA", 20, shift="pagi"),
    Kelas("TI-22-PA", 20, shift="pagi"), Kelas("TI-23-PA", 20, shift="pagi"),
    Kelas("TI-20-KA", 20, shift="malam"), Kelas('TI-24-PA', 20, shift="pagi"),
    Kelas('TI-21-KA', 25, shift="malam"), Kelas("TI-25-PA", 20, shift="pagi"),
    Kelas("TI-26-PA", 20, shift="pagi"), Kelas("TI-27-PA", 20, shift="pagi"),
    Kelas("TI-28-PA", 20, shift="pagi"), Kelas("TI-22-KA", 20, shift="malam"),
    Kelas('TI-29-PA', 20, shift="pagi"), Kelas('TI-23-KA', 25, shift="malam"),
    Kelas("TI-30-PA", 20, shift="pagi"), Kelas("TI-31-PA", 20, shift="pagi"),
    Kelas("TI-32-PA", 20, shift="pagi"), Kelas("TI-33-PA", 20, shift="pagi"),
    Kelas("TI-24-KA", 20, shift="malam"), Kelas('TI-34-PA', 20, shift="pagi"),
    Kelas('TI-25-KA', 25, shift="malam")
]

dosen = [
    Dosen("Septian Cahyadi", [Schedule("13:15", "15:00", "Thu"), Schedule("20:15", "22:00", "Wed")], mengajar=["Basis Data"]),
    Dosen("Edi Nurachmad", [Schedule("13:15", "15:00", "Mon"), Schedule("15:15", "17:00", "Mon")], mengajar=["Lab Pemrograman Web"]),
    Dosen("Anton Sukamto", [Schedule("20:15", "22:00", "Tue"), Schedule("15:15", "17:00", "Tue")], mengajar=["Manajemen Projek"]),
    Dosen("Febri Damatraseta", [Schedule("13:15", "15:00", "Wed"), Schedule("15:15", "17:00", "Wed")], mengajar=["Kecerdasan Buatan"]),
    Dosen("Suci Sutjipto", [Schedule("13:15", "15:00", "Fri"), Schedule("15:15", "17:00", "Fri")], mengajar=["Statistika"]),
    Dosen("Isnan Mulia", [Schedule("13:15", "15:00", "Mon"), Schedule("20:15", "22:00", "Mon")], mengajar=["Jaringan Komputer"]),
    Dosen("Lina Fithriyah", [Schedule("13:15", "15:00", "Tue"), Schedule("15:15", "17:00", "Tue")], mengajar=["Sistem Operasi"]),
    Dosen("Dewi Suryati", [Schedule("13:15", "15:00", "Wed"), Schedule("15:15", "17:00", "Wed")], mengajar=["Manajemen Sistem Informasi"]),
    Dosen("Ahmad Farhan", [Schedule("13:15", "15:00", "Thu"), Schedule("15:15", "17:00", "Thu")], mengajar=["Pemrograman Dasar"]),
    Dosen("Tina Larasati", [Schedule("13:15", "15:00", "Fri"), Schedule("15:15", "17:00", "Fri")], mengajar=["Algoritma dan Pemrograman"]),
    Dosen("Yoga Pratama", [Schedule("13:15", "15:00", "Mon"), Schedule("15:15", "17:00", "Mon")], mengajar=["teori graf"]),
    Dosen("Budi Santoso", [Schedule("13:15", "15:00", "Tue"), Schedule("15:15", "17:00", "Tue")], mengajar=[ "Pemrograman Lanjut"]),
    Dosen("Rina Suryani", [Schedule("13:15", "15:00", "Wed"), Schedule("15:15", "17:00", "Wed")], mengajar=["Tata kelola"]),
    Dosen("Gilang Rahman", [Schedule("13:15", "15:00", "Thu"), Schedule("15:15", "17:00", "Thu")], mengajar=["Keamanan Informasi"]),
    Dosen("Ika Permatasari", [Schedule("13:15", "15:00", "Fri"), Schedule("15:15", "17:00", "Fri")], mengajar=["Rekayasa Perangkat Lunak"]),
    Dosen("Farah Azmi", [Schedule("13:15", "15:00", "Mon"), Schedule("15:15", "17:00", "Mon")], mengajar=["TIK"]),
    Dosen("Ali Rahman", [Schedule("13:15", "15:00", "Tue"), Schedule("15:15", "17:00", "Tue")], mengajar=["Matematika Diskrit"]),
    Dosen("Siti Nurjanah", [Schedule("13:15", "15:00", "Wed"), Schedule("15:15", "17:00", "Wed")], mengajar=["Matematika Dasar"])
]

course_classes = [
    CourseClass("Basis Data"), CourseClass("Tata Kelola TI"), CourseClass("Pengantar Teknologi Informasi"),
    CourseClass("Matematika Diskrit"), CourseClass("Lab Pemrograman Web", is_lab=True),
    CourseClass("Kecerdasan Buatan"), CourseClass("Manajemen Projek"), CourseClass("Matematika Dasar"),
    CourseClass("Jaringan Komputer"), CourseClass("Keamanan Informasi"), CourseClass("Sistem Operasi"),
    CourseClass("Pemrograman Lanjut"), CourseClass("Pemrograman Dasar"), CourseClass("Sistem Basis Data"),
    CourseClass("Sistem Informasi"), CourseClass("Rekayasa Perangkat Lunak"), CourseClass("Manajemen Sistem Informasi"),
    CourseClass("Teori Graf"), CourseClass("Algoritma dan Pemrograman"), CourseClass("Statistika"), CourseClass("TIK")
]

rooms = [
    Room("415", 40), Room("409", 40), Room("408", 40), Room("215", 20, is_lab=True), Room("210", 20, is_lab=True),
    Room("411", 40), Room("412", 40), Room("413", 40), Room("214", 20, is_lab=True), Room("211", 20, is_lab=True),
    Room("416", 40), Room("417", 40), Room("418", 40), Room("216", 20, is_lab=True), Room("212", 20, is_lab=True)
]

schedules = [
    Schedule("08:15", "10:00", "Mon"), Schedule("10:15", "12:00", "Mon"),
    Schedule("13:15", "15:00", "Mon"), Schedule("15:15", "17:00", "Mon"),
    Schedule("08:15", "10:00", "Tue"), Schedule("10:15", "12:00", "Tue"),
    Schedule("13:15", "15:00", "Tue"), Schedule("15:15", "17:00", "Tue"),
    Schedule("08:15", "10:00", "Wed"), Schedule("10:15", "12:00", "Wed"),
    Schedule("13:15", "15:00", "Wed"), Schedule("15:15", "17:00", "Wed"),
    Schedule("08:15", "10:00", "Thu"), Schedule("10:15", "12:00", "Thu"),
    Schedule("13:15", "15:00", "Thu"), Schedule("15:15", "17:00", "Thu"),
    Schedule("18:00", "20:00", "Mon"), Schedule("20:15", "22:00", "Mon"),
    Schedule("18:00", "20:00", "Tue"), Schedule("20:15", "22:00", "Tue"),
    Schedule("18:00", "20:00", "Wed"), Schedule("20:15", "22:00", "Wed"),
    Schedule("18:00", "20:00", "Thu"), Schedule("20:15", "22:00", "Thu"),
    Schedule("08:15", "10:00", "Fri"), Schedule("10:15", "12:00", "Fri"),
    Schedule("13:15", "15:00", "Fri"), Schedule("15:15", "17:00", "Fri"),
    Schedule("08:15", "10:00", "Sat"), Schedule("10:15", "12:00", "Sat"),
    Schedule("13:15", "15:00", "Sat"), Schedule("15:15", "17:00", "Sat"),
    Schedule("18:00", "20:00", "Fri"), Schedule("20:15", "22:00", "Fri"),
    Schedule("18:00", "20:00", "Sat"), Schedule("20:15", "22:00", "Sat")
]

dosen_course_class_mapping = {
    "Septian Cahyadi": {"Basis Data": ["TI-20-PA", "TI-21-PA"]},
    "Edi Nurachmad": {"Lab Pemrograman Web": ["TI-22-PA", "TI-23-PA"]},
    "Anton Sukamto": {"Manajemen Projek": ["TI-24-PA", "TI-25-PA"]},
    "Febri Damatraseta": {"Kecerdasan Buatan": ["TI-26-PA", "TI-27-PA"]},
    "Suci Sutjipto": {"Statistika": ["TI-28-PA", "TI-29-PA"]},
    "Isnan Mulia": {"Jaringan Komputer": ["TI-30-PA", "TI-31-PA"]},
    "Lina Fithriyah": {"Sistem Operasi": ["TI-32-PA", "TI-33-PA"]},
    "Dewi Suryati": {"Manajemen Sistem Informasi": ["TI-34-PA"]},
    "Ahmad Farhan": {"Pemrograman Dasar": ["TI-20-KA", "TI-21-KA"]},
    "Tina Larasati": {"Algoritma dan Pemrograman": ["TI-22-KA", "TI-23-KA"]},
    "Yoga Pratama": {"Teori Graf": ["TI-24-KA", "TI-25-KA"]},
    "Budi Santoso": {"Pemrograman Lanjut": ["TI-20-PA", "TI-21-PA"]},
    "Rina Suryani": {"Tata Kelola TI": ["TI-23-KA", "TI-23-PA"]},
    "Gilang Rahman": {"Keamanan Informasi": ["TI-24-PA", "TI-25-PA"]},
    "Ika Permatasari": {"Rekayasa Perangkat Lunak": ["TI-26-PA", "TI-27-PA"]},
    "Farah Azmi": {"TIK": ["TI-24-PA", "TI-24-KA"]},
    "Ali Rahman": {"Matematika Diskrit": ["TI-20-PA", "TI-20-KA"]},
    "Siti Nurjanah": {"Matematika Dasar": ["TI-21-PA", "TI-21-KA"]}
}

def create_initial_population(population_size):
    population = []
    for _ in range(population_size):
        schedule = []
        for teacher, courses in dosen_course_class_mapping.items():
            for course_name, class_list in courses.items():
                for class_name in class_list:
                    # Use a try-except block to handle potential errors
                    try:
                        course = next(c for c in course_classes if c.nama == course_name)
                        class_ = next(cl for cl in classes if cl.nama == class_name)
                        teacher_obj = next(t for t in dosen if t.nama == teacher)
                        room = random.choice([r for r in rooms if r.kapasitas >= class_.kapasitas and (course.is_lab == r.is_lab)])
                        time = random.choice(schedules)
                        schedule.append((course, room, time, teacher_obj, class_))
                    except StopIteration:
                        print(f"Warning: No match found for course: {course_name}, class: {class_name}, or teacher: {teacher}")
        population.append(schedule)
    return population

# Initial Population
population_size = 50
population = create_initial_population(population_size)


def generate_random_schedule():
    schedule = []
    for teacher, courses in dosen_course_class_mapping.items():
        for course_name, class_list in courses.items():
            for class_name in class_list:
                try:
                    course = next(c for c in course_classes if c.nama == course_name)
                    class_ = next(cl for cl in classes if cl.nama == class_name)
                    teacher_obj = next(t for t in dosen if t.nama == teacher)
                    room = get_random_room(course)
                    time = random.choice(schedules)
                    schedule.append((course, room, time, teacher_obj, class_))
                except StopIteration:
                    print(f"Warning: No match found for course: {course_name}, class: {class_name}, or teacher: {teacher}")
    return schedule

def get_random_room(course):
    valid_rooms = [r for r in rooms if r.is_lab == course.is_lab]
    return random.choice(valid_rooms) if valid_rooms else None

def fitness(schedule):
    fitness_value = 0
    violating_preferences = []
    time_slots = {}
    dosen_mapping = initialize_dosen_mapping()

    for slot in schedule:
        fitness_value += evaluate_slot(slot, time_slots, dosen_mapping, violating_preferences)

    return fitness_value, violating_preferences

def evaluate_slot(slot, time_slots, dosen_mapping, violating_preferences):
    course, room, time, teacher, class_ = slot
    value = 0

    value += check_lab_class_in_lab_room(course, room)
    value += check_teacher_preference(time, teacher, violating_preferences)
    value += check_class_shift(time, class_)
    # Pass 'class_' and 'violating_preferences' to check_time_conflicts
    value += check_time_conflicts(time_slots, time, room, teacher, class_, violating_preferences)
    value += check_dosen_mapping(dosen_mapping, teacher, course, class_, slot)

    return value


def check_lab_class_in_lab_room(course, room):
    if course.is_lab and not room.is_lab:
        return -10
    return 0

def check_teacher_preference(time, teacher, violating_preferences):
    preference_matched = any(pref_matches(time, p) for p in teacher.preferred_time_slots)
    if not preference_matched:
        violating_preferences.append(f"{teacher.nama} prefers {time.day} {time.start_time}-{time.end_time}")
        return -2
    return 0

def pref_matches(time, pref):
    return (time.start_time == pref.start_time and
            time.end_time == pref.end_time and
            time.day == pref.day)

def check_class_shift(time, class_):
    if (class_.shift == 'pagi' and time.start_time >= '18:00') or (class_.shift == 'malam' and time.start_time < '18:00'):
        return -5
    return 0

def check_time_conflicts(time_slots, time, room, teacher, class_, violating_preferences): # This definition remains
    key = (time.start_time, time.day)
    if key in time_slots:
        existing_room, existing_teacher, existing_class = time_slots[key]
        if existing_room == room:
            violating_preferences.append(f"Room conflict: Room {room.nama} is booked at {time.start_time}-{time.end_time} on {time.day}")
            return -20
        if existing_teacher == teacher:
            violating_preferences.append(f"Teacher conflict: {teacher.nama} is scheduled to teach at {time.start_time}-{time.end_time} on {time.day}")
            return -20
        if existing_class == class_:
            violating_preferences.append(f"Class conflict: Class {class_.nama} is scheduled at {time.start_time}-{time.end_time} on {time.day}")
            return -20
    time_slots[key] = (room, teacher, class_) # Store the class as well to check for class conflicts
    return 0

def check_dosen_mapping(dosen_mapping, teacher, course, class_, slot):
    if (teacher.nama, course.nama, class_.nama) not in dosen_mapping:
        return -5
    dosen_mapping[(teacher.nama, course.nama, class_.nama)].append(slot)
    return 0

def initialize_dosen_mapping():
    dosen_mapping = {}
    for d in dosen:
        for mengajar in d.mengajar:
            for c in classes:
                dosen_mapping[(d.nama, mengajar, c.nama)] = []
    return dosen_mapping

def enforce_shift_constraints(schedule):
    new_schedule = []
    for slot in schedule:
        course, room, time, teacher, class_ = slot
        if class_.shift == 'malam' and time.start_time < '18:00':
            new_time = next((t for t in schedules if t.start_time >= '18:00'), None)
            if new_time:
                slot = (course, room, new_time, teacher, class_)
        elif class_.shift == 'pagi' and time.start_time >= '18:00':
            new_time = next((t for t in schedules if t.start_time < '18:00'), None)
            if new_time:
                slot = (course, room, new_time, teacher, class_)
        new_schedule.append(slot)
    return new_schedule

def enforce_shift_constraints(schedule):
    # Enforce shift constraints
    new_schedule = []
    for slot in schedule:
        course, room, time, teacher, class_ = slot
        if class_.shift == 'malam' and time.start_time < '18:00':
            # Find a suitable evening time slot
            new_time = next((t for t in schedules if t.start_time >= '18:00'), None)
            if new_time:
                slot = (course, room, new_time, teacher, class_)
        elif class_.shift == 'pagi' and time.start_time >= '18:00':
            # Find a suitable morning time slot
            new_time = next((t for t in schedules if t.start_time < '18:00'), None)
            if new_time:
                slot = (course, room, new_time, teacher, class_)
        new_schedule.append(slot)
    return new_schedule



def enforce_no_class_overlap(schedule):
    """
    Enforces no overlap of courses within the same class and same time slot.
    """
    class_schedules = {}
    new_schedule = []

    for slot in schedule:
        course, room, time, teacher, class_ = slot
        if class_.nama not in class_schedules:
            class_schedules[class_.nama] = []

        # Check for time conflicts within the same class
        conflict = False
        for existing_slot in class_schedules[class_.nama]:
            existing_course, existing_room, existing_time, _, _ = existing_slot
            if existing_time.day == time.day and (
                (existing_time.start_time <= time.start_time < existing_time.end_time) or
                (time.start_time <= existing_time.start_time < time.end_time)
            ):
                conflict = True
                print(f"Conflict detected for {class_.nama}: {course.nama} overlaps with {existing_course.nama} on {time.day} at {time.start_time}-{time.end_time}")
                break  # No need to check further for this slot

        if not conflict:
            class_schedules[class_.nama].append(slot)
            new_schedule.append(slot)

    return new_schedule

def enforce_no_teacher_overlap(schedule):
    """
    Enforces no overlap of courses for the same teacher at the same time.
    """
    teacher_schedules = {}
    new_schedule = []

    for slot in schedule:
        course, room, time, teacher, class_ = slot
        if teacher.nama not in teacher_schedules:
            teacher_schedules[teacher.nama] = []

        # Check for time conflicts for the teacher
        conflict = False
        for existing_slot in teacher_schedules[teacher.nama]:
            existing_course, existing_room, existing_time, _, _ = existing_slot
            if existing_time.day == time.day and (
                (existing_time.start_time <= time.start_time < existing_time.end_time) or
                (time.start_time <= existing_time.start_time < time.end_time)
            ):
                conflict = True
                print(f"Conflict detected for {teacher.nama}: {course.nama} overlaps with {existing_course.nama} on {time.day} at {time.start_time}-{time.end_time}")
                break

        if not conflict:
            teacher_schedules[teacher.nama].append(slot)
            new_schedule.append(slot)

    return new_schedule

def resolve_conflicts(schedule):
  """
  Resolves conflicts in a schedule by iteratively swapping courses between slots.

  Args:
    schedule: A list of tuples representing the schedule, where each tuple contains
      (course, room, time, teacher, class).

  Returns:
    A conflict-free schedule.
  """

  # Track the number of conflicts
  num_conflicts = 0

  # Loop until there are no more conflicts
  while num_conflicts > 0:
    # Initialize the number of conflicts for this iteration
    num_conflicts = 0

    # Iterate through each slot in the schedule
    for i in range(len(schedule)):
      # Get the course, room, time, teacher, and class for the current slot
      course1, room1, time1, teacher1, class1 = schedule[i]

      # Iterate through all other slots after the current slot
      for j in range(i + 1, len(schedule)):
        # Get the course, room, time, teacher, and class for the other slot
        course2, room2, time2, teacher2, class2 = schedule[j]

        # Check if there is a conflict between the two slots
        if time1 == time2 and (class1 == class2 or teacher1 == teacher2):
          # Swap the courses between the two slots
          schedule[i] = (course2, room2, time2, teacher2, class2)
          schedule[j] = (course1, room1, time1, teacher1, class1)

          # Increment the number of conflicts resolved
          num_conflicts += 1

  # Return the conflict-free schedule
  return schedule




def genetic_algorithm(population, generations, mutation_rate):
    fitness_history = []
    for generation in range(generations):
        population = sorted(population, key=lambda x: fitness(x), reverse=True)
        next_generation = population[:2]

        for i in range(len(population) // 2 - 1):
            parent1 = random.choice(population[:10])
            parent2 = random.choice(population[:10])
            child1, child2 = crossover(parent1, parent2)
            next_generation.extend([mutate(child1, mutation_rate), mutate(child2, mutation_rate)])

        population = next_generation
        best_fitness, _ = fitness(population[0])
        fitness_history.append(best_fitness)

    best_solution = population[0]
    _, best_violating_preferences = fitness(best_solution)
    return best_solution, best_violating_preferences, fitness_history

def crossover(parent1, parent2):
    point = random.randint(1, len(parent1) - 1)
    child1 = parent1[:point] + parent2[point:]
    child2 = parent2[:point] + parent1[point:]
    return child1, child2

def mutate(individual, mutation_rate):
    if random.random() < mutation_rate:
        index = random.randint(0, len(individual) - 1)
        course, room, time, teacher, class_ = individual[index]
        valid_teachers = [d for d in dosen if course.nama in d.mengajar]
        if valid_teachers:
            new_teacher = random.choice(valid_teachers)
            valid_classes = dosen_course_class_mapping[new_teacher.nama][course.nama]
            if valid_classes:
                new_class = random.choice([c for c in classes if c.nama in valid_classes])
                new_room = get_random_room(course)
                new_time = random.choice(schedules)
                individual[index] = (course, new_room, new_time, new_teacher, new_class)
    return individual

def simulated_annealing(solution, temperature, cooling_rate):
    fitness_history = []
    current_solution = solution
    current_fitness, current_violating_preferences = fitness(current_solution)
    fitness_history.append(current_fitness)

    while temperature > 1:
        new_solution = mutate(current_solution[:], 1.0)
        new_fitness, new_violating_preferences = fitness(new_solution)

        if (new_fitness, len(new_violating_preferences)) > (current_fitness, len(current_violating_preferences)) or \
           math.exp(((new_fitness - current_fitness) - (len(new_violating_preferences) - len(current_violating_preferences))) / temperature) > random.random():
            current_solution, current_fitness, current_violating_preferences = new_solution, new_fitness, new_violating_preferences

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return current_solution, current_violating_preferences, fitness_history

# Initial Population
population_size = 50
population = create_initial_population(population_size)

# Parameters
generations = 500
mutation_rate = 0.05
initial_temperature = 10000
cooling_rate = 0.99

# Running the hybrid algorithm
best_solution, best_violating_preferences, ga_fitness_history = genetic_algorithm(population, generations, mutation_rate)
best_solution, best_violating_preferences, sa_fitness_history = simulated_annealing(best_solution, initial_temperature, cooling_rate)
combined_fitness_history = ga_fitness_history + sa_fitness_history

# Enforce shift constraints
best_solution = enforce_shift_constraints(best_solution)
best_solution = enforce_no_class_overlap(best_solution)
best_solution = enforce_no_teacher_overlap(best_solution)
best_solution = resolve_conflicts(best_solution)

# Print the best solution and score
best_score, _ = fitness(best_solution)  # Calculate the score
print("Best Solution (Score: {}):".format(int(abs(best_score))))
class_schedules = {}  # Dictionary to store schedules by class

for slot in best_solution:
    course, room, time, teacher, class_ = slot
    print(f"Course {course.nama} in Room {room.nama} at {time.start_time}-{time.end_time} on {time.day} by {teacher.nama} for Class {class_.nama}")


# Print the violating preferences
if best_violating_preferences:
    print("\nViolating Preferences:")
    for pref in best_violating_preferences:
        print(pref)
else:
    print("\nNo violating preferences found.")
# Plot Fitness History for Genetic Algorithm
plt.figure(figsize=(10, 5))
plt.plot(ga_fitness_history)
plt.xlabel("Generation")
plt.ylabel("Fitness Score")
plt.title("Genetic Algorithm - Fitness over Generations")
plt.grid(True)
plt.show()

# Plot Fitness History for Simulated Annealing
plt.figure(figsize=(10, 5))
plt.plot(sa_fitness_history)
plt.xlabel("Iteration")
plt.ylabel("Fitness Score")
plt.title("Simulated Annealing - Fitness over Iterations")
plt.grid(True)
plt.show()

# Plot Combined Fitness History for Hybrid Algorithm
plt.figure(figsize=(10, 5))
plt.plot(combined_fitness_history)
plt.xlabel("Generation/Iteration")
plt.ylabel("Fitness Score")
plt.title("Hybrid Algorithm (Genetic Algorithm + Simulated Annealing) - Fitness over Generations/Iterations")
plt.grid(True)
plt.show()

# Graphical Schedule
days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
time_slots = ["08:15-10:00", "10:15-12:00", "13:15-15:00", "15:15-17:00", "18:00-20:00", "20:15-22:00"]

class_schedules = {}  # Dictionary to store schedules by class

for slot in best_solution:
    course, room, time, teacher, class_ = slot
    if class_.nama not in class_schedules:
        class_schedules[class_.nama] = []
    class_schedules[class_.nama].append((course.nama, room.nama, time.day, time.start_time, time.end_time, teacher.nama))

for class_name, schedule in class_schedules.items():
    fig, ax = plt.subplots(figsize=(5, 3))

    for slot in schedule:
        course, room, day, time_start, time_end, teacher = slot
        day_index = days.index(day)
        time_index = time_slots.index(f"{time_start}-{time_end}")
        ax.text(day_index, time_index, f"{course}\n{room}\n{teacher}",
                ha="center", va="center", bbox=dict(facecolor='lightblue', edgecolor='black', boxstyle='round,pad=0.5'))

    ax.set_xticks(range(len(days)))
    ax.set_xticklabels(days)
    ax.set_yticks(range(len(time_slots)))
    ax.set_yticklabels(time_slots)
    ax.set_xlabel("Day")
    ax.set_ylabel("Time Slot")
    ax.set_title(f"Schedule for Class {class_name}")

    plt.show()